#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//1.数组指针――指针
int main() {
	int* p = NULL;//p：整型指针――指向整型的指针――可以存放整型的地址

	char* pc = NULL;//pc：字符指针――指向字符的指针――可以存放字符的地址

	//数组指针――指向数组的指针――存放数组的地址
		//int arr[10] = { 0 };
	//arr 是首元素地址
	//&arr[0] 是首元素地址
	//&arr 数组的地址――可以存放于数组指针中去
	int	arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*p)[10] = &arr;//数组的地址,存放于数组指针中去
						//p的前面是*，说明p是一个指针，而外面的 int [10]则说明他是一个数组，数组的元素类型是int型
						//p就是一个数组指针
	return 0;
}
int* p1[10];//他是一个有十个元素的数组，数组的元素类型是int * 的
int(*p2)[10];//它是一个指针，指针指向的是含有10个元素的数组，数组类型是 int 型的

//2.
int main() {
	char* arr[5];
	char* (*pa)[5] = &arr;//*pa说明他是一个指针，指向含有5个元素的数组，数组的元素类型是char *的
		//pa:指针变量的变量名
		//*:告诉我们他是一个指针
		//[5]:告诉我们它指向的数组是5个元素
		//int *:pa指向的数组的元素类型是char *

	int arr2[10] = { 0 };
	int(*pa2)[10] = &arr2;
	return 0;
}

//3.&数组名和数组名	的区别:

//数组名绝大多数的情况下表示的是首元素的地址
//&数组名表示取出数组的地址――这样就可以更好地将数组存放到数组指针里面去了
//如:		arr = 0133FBBO	//首元素地址
//		   &arr = 0133FBBO	//数组的地址
//		  arr+1 = 0133FBB4	//首元素地址加1，表示跳过一个元素
//		 &arr+1 = 0133FBD8	//数组的地址加1，表示跳过一个数组

//4.数组指针的用法:
//4.1
int main() {
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;//把整个数组的地址交给了pa
	//把数组内容全部打印下来
	int i = 0;
	for (i = 0; i < 10; i++) {
		printf("%d ", (*pa)[i]);//pa是数组的地址，那么：*pa 就相当于拿到了数组的数组名（数组的地址解引用相当于拿到了整个数组）
					//(*pa)就相当于是首元素地址――数组名，即arr 
	}
	
	for (i = 0; i < 10; i++) {
		printf("%d ", *(*pa + i));//*pa找到数组，*pa == arr:即相当于首元素地址。
								  //*pa + i:首元素地址加i,就是第i个元素的地址
				   				  //*(*pa + i)相当于地址解引用找到了对应的元素
	}
	return 0;
}
//但上面两种方法都很别扭，于是可以不用数组指针：
int main() {
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* p = arr;//这个指针指向第一个元素
	int  i = 0;
	for (i = 0; i < 10; i++) {
		printf("%d ", *(p + i));		//因为p是指向第一个元素的
									    //p+i:跳过i个元素，指向下标为i的元素  
									    //*（p + i）:找到其中的一个元素
	}									//所以，虽然可以用 数组指针 进行赋值，但不是这么用的
	return 0;
}
//4.2，一般情况下，数组指针都是用于二维数组及以上的
void print1(int arr[3][5],int x,int y) {//参数是数组的形式
	int i = 0;
	int j = 0;
	for (i = 0; i < x; i++) {
		for (j = 0; j < y; j++) {
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}
void print2(int (* p)[5], int x, int y) {//参数是指针的形式
											//指针指向的不是二维数组，而是一维数组的
	int i = 0;
	for (i = 0; i < x; i++) {
		int j = 0;
		for(j = 0;j<y;j++){
			printf("%d ", *(*(p + i) + j));//p+i表示跳过几行，
										   //*(p + i)相当于找到了一维数组的数组名，即某一行
										   //*(p + i)+ j：找到下标为j的元素的地址,再解引用找到对应元素
										   
			printf("%d ", *(p + i)[j] );//*(p + i)：是第一行的数组，等效于数组名，
										  //*(p + i)[j] == arr[j]
										  
			//因为arr[i] == *(p + i) == *(arr + i) == p[i]，所以 *(*(p + i) + j) 等价于:
			printf("%d ", *(p[i] + j));//又等价为
			printf("%d ", p[i][j]);
		}
	
	}

}
int main() {
	int arr[3][5] = { {1,2,3,4,5,} ,{2,3,4,5,6},{3,4,5,6,7} };
	//打印二维数组――这儿是封装了一个数组
	print1(arr, 3, 5);//arr -- 数组名――首元素地址
					  //首元素是: {1,2,3,4,5}
					  //所以首元素地址是:数组 {1,2,3,4,5} 的地址
	print2(arr, 3, 5);//arr相当于传的是一维数组的地址――因此应该用数组指针接收   (数组传的是第一行的地址)
	return 0;
}
//**************************************
//诠释 [j]的含义
int main() {
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	int* p = arr;//把数组名交给整型指针（数组名是首元素地址，首元素是整型）arr就是整型的地址，放到整型的指针中去
	//这儿是将arr赋值给p,说明arr 和 p是一回事
	for (i = 0; i < 10; i++) {
		printf("%d ", *(p + i));//p:首元素地址
								//p + i:第i个元素的地址，再解引用，指向元素
		printf("%d ", *(arr + i));//因为arr 和 p是一回事，所以这儿也可以这么写
		printf("%d ", arr[i]);
		printf("%d ", p[i]);
		//arr[i] == *(p + i) == *(arr + i) == p[i]
	}
	return 0;
}

//*******************************************
//区别：
int arr[5];//arr是一个5个元素的整型数组
int* arr1[10];//arr1 是一个数组，数组有10个元素，每个元素的类型是 int* ,arr1是指针数组
int(*arr2)[10];//arr2是一个指针，指针指向了一个数组，数组有10个元素，每个元素的类型是int ,arr2是指针数组
int(*arr3[10])[5];//arr3是一个数组，该数组有十个元素，每个元素是一个数组指针，该数组指向的数组有5个元素，每个元素是int
//数组名：arr3[10]
//数组类型：int(*)[5]//数组指针
